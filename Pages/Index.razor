@page "/"
@using EbayTemplateGenerator.Models
@using EbayTemplateGenerator.Services
@using System.Text.Json
@inject TemplateGeneratorService TemplateGenerator
@inject Blazored.LocalStorage.ILocalStorageService LocalStorage
@inject IJSRuntime JS
@implements IAsyncDisposable

<div class="app-container">
    <header class="app-header">
        <h1>relexx' Template Generator</h1>
        
        <div class="header-center">
            <span class="header-title">@(string.IsNullOrWhiteSpace(article.Title) ? "Neuer Artikel" : article.Title)</span>
            <span class="header-divider">‚îÇ</span>
            <span class="header-layout">@currentLayout.Name</span>
        </div>
        
        <div class="phase-indicator">
            @for (var i = 0; i <= 3; i++)
            {
                var phase = i;
                <div class="phase @GetPhaseClass(phase)" @onclick="() => GoToPhase(phase)">
                    <span class="phase-number">@phase</span>
                    <span class="phase-label">@GetPhaseName(phase)</span>
                </div>
                @if (i < 3)
                {
                    <div class="phase-connector @(currentPhase > phase ? "completed" : "")"></div>
                }
            }
        </div>
    </header>

    <main class="app-main">
        @switch (currentPhase)
        {
            case 0:
                @RenderLayoutPhase()
                break;
            case 1:
                @RenderInputPhase()
                break;
            case 2:
                @RenderPreviewPhase()
                break;
            case 3:
                @RenderHtmlPhase()
                break;
        }
    </main>
</div>

@RenderDialogs()
@RenderNotification()

@code {
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê STATE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    private int currentPhase;
    private List<LayoutTemplate> layouts = new();
    private string selectedLayoutId = LayoutTemplate.StandardLayoutId;
    private LayoutTemplate currentLayout = LayoutTemplate.CreateStandard();
    private string? selectedBlockId;
    private BlockDefinition? SelectedBlock => currentLayout.Blocks.FirstOrDefault(b => b.Id == selectedBlockId);
    
    private ArticleData article = new();
    private string generatedHtml = string.Empty;
    
    private bool showAddBlockDialog;
    private bool showImportConflict;
    private ArticleData? importedArticle;
    
    private string notification = string.Empty;
    private bool notificationSuccess;
    private CancellationTokenSource? notificationCts;
    
    private DotNetObjectReference<Index>? dotNetHelper;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê LIFECYCLE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    protected override async Task OnInitializedAsync()
    {
        await LoadLayouts();
        await LoadArticle();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (currentPhase == 0)
        {
            await InitSortable();
        }
    }

    public async ValueTask DisposeAsync()
    {
        notificationCts?.Cancel();
        notificationCts?.Dispose();
        
        try
        {
            await JS.InvokeVoidAsync("destroySortable", "block-list");
        }
        catch { /* Ignore JS errors during dispose */ }
        
        dotNetHelper?.Dispose();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê SORTABLE ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    private async Task InitSortable()
    {
        dotNetHelper ??= DotNetObjectReference.Create(this);
        try
        {
            await JS.InvokeVoidAsync("initSortable", "block-list", dotNetHelper);
        }
        catch { /* Element might not exist yet */ }
    }

    [JSInvokable]
    public async Task OnBlockReordered(int oldIndex, int newIndex)
    {
        if (oldIndex == newIndex) return;
        
        var orderedBlocks = currentLayout.Blocks.OrderBy(b => b.Order).ToList();
        var movedBlock = orderedBlocks[oldIndex];
        orderedBlocks.RemoveAt(oldIndex);
        orderedBlocks.Insert(newIndex, movedBlock);
        
        for (var i = 0; i < orderedBlocks.Count; i++)
        {
            orderedBlocks[i].Order = i;
        }
        
        currentLayout.Blocks = orderedBlocks;
        await SaveLayouts();
        StateHasChanged();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê LAYOUT MANAGEMENT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    private async Task LoadLayouts()
    {
        try
        {
            var saved = await LocalStorage.GetItemAsync<List<LayoutTemplate>>(Constants.Storage.LayoutsKey);
            layouts = saved ?? new();
            
            if (!layouts.Exists(l => l.IsDefault))
            {
                layouts.Insert(0, LayoutTemplate.CreateStandard());
            }
            
            currentLayout = layouts.Find(l => l.Id == selectedLayoutId) ?? layouts[0];
            selectedLayoutId = currentLayout.Id;
        }
        catch
        {
            layouts = new() { LayoutTemplate.CreateStandard() };
            currentLayout = layouts[0];
        }
    }

    private async Task SaveLayouts()
    {
        currentLayout.ModifiedAt = DateTime.UtcNow;
        await LocalStorage.SetItemAsync(Constants.Storage.LayoutsKey, layouts);
    }

    private async Task OnLayoutSelected()
    {
        currentLayout = layouts.Find(l => l.Id == selectedLayoutId) ?? layouts[0];
        selectedBlockId = null;
        article.Layout = currentLayout;
        await InitSortable();
    }

    private async Task CreateNewLayout()
    {
        var newLayout = new LayoutTemplate
        {
            Name = "Neues Layout",
            Blocks = new() 
            { 
                BlockDefinition.CreateDefault(BlockType.Image), 
                BlockDefinition.CreateDefault(BlockType.RichText, 1) 
            }
        };
        layouts.Add(newLayout);
        selectedLayoutId = newLayout.Id;
        currentLayout = newLayout;
        selectedBlockId = null;
        await SaveLayouts();
    }

    private async Task DuplicateLayout()
    {
        var copy = currentLayout.Clone();
        layouts.Add(copy);
        selectedLayoutId = copy.Id;
        currentLayout = copy;
        selectedBlockId = null;
        await SaveLayouts();
    }

    private async Task DeleteLayout()
    {
        if (currentLayout.IsDefault || layouts.Count <= 1) return;
        
        layouts.Remove(currentLayout);
        currentLayout = layouts[0];
        selectedLayoutId = currentLayout.Id;
        selectedBlockId = null;
        await SaveLayouts();
    }

    private async Task ExportLayout()
    {
        var json = JsonSerializer.Serialize(currentLayout, Helpers.JsonOptions);
        var fileName = $"layout-{currentLayout.Name}_{DateTime.UtcNow:yyyy-MM-dd_HHmm}.json";
        await JS.InvokeVoidAsync("downloadFile", fileName, "application/json", json);
    }

    private async Task ImportLayout(InputFileChangeEventArgs e)
    {
        try
        {
            await using var stream = e.File.OpenReadStream();
            var imported = await JsonSerializer.DeserializeAsync<LayoutTemplate>(stream);
            
            if (imported is null) return;
            
            imported.Id = Helpers.GenerateShortId();
            imported.IsDefault = false;
            layouts.Add(imported);
            selectedLayoutId = imported.Id;
            currentLayout = imported;
            await SaveLayouts();
            await ShowNotification("‚úì Layout importiert!", true);
        }
        catch (Exception ex)
        {
            await ShowNotification($"Fehler: {ex.Message}", false);
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê BLOCK MANAGEMENT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    private void SelectBlock(BlockDefinition block) => selectedBlockId = block.Id;

    private async Task AddBlock(BlockType type)
    {
        var order = currentLayout.Blocks.Count > 0 ? currentLayout.Blocks.Max(b => b.Order) + 1 : 0;
        var block = BlockDefinition.CreateDefault(type, order);
        currentLayout.Blocks.Add(block);
        selectedBlockId = block.Id;
        showAddBlockDialog = false;
        await SaveLayouts();
        await InitSortable();
    }

    private async Task DeleteBlock()
    {
        if (SelectedBlock is null) return;
        
        currentLayout.Blocks.Remove(SelectedBlock);
        currentLayout.ReorderBlocks();
        selectedBlockId = null;
        await SaveLayouts();
        await InitSortable();
    }

    private async Task OnBlockTypeChanged()
    {
        if (SelectedBlock is null) return;
        
        SelectedBlock.Options = BlockOptions.CreateDefault(SelectedBlock.Type);
        SelectedBlock.Icon = SelectedBlock.Type.GetDefaultIcon();
        SelectedBlock.Title = SelectedBlock.Type.GetDefaultTitle();
        await SaveLayouts();
    }

    private async Task SetBlockIcon(string icon)
    {
        if (SelectedBlock is not null)
        {
            SelectedBlock.Icon = icon;
            await SaveLayouts();
        }
    }

    private async Task SetBullet(string bullet)
    {
        if (SelectedBlock is not null)
        {
            SelectedBlock.Options.BulletChar = bullet;
            await SaveLayouts();
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê ARTICLE MANAGEMENT ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    private async Task LoadArticle()
    {
        try
        {
            var saved = await LocalStorage.GetItemAsync<ArticleData>(Constants.Storage.ArticleKey);
            if (saved is not null)
            {
                article = saved;
                if (article.Layout?.Id is not null && layouts.Exists(l => l.Id == article.Layout.Id))
                {
                    selectedLayoutId = article.Layout.Id;
                    currentLayout = layouts.First(l => l.Id == article.Layout.Id);
                }
            }
            else
            {
                article = new() { Layout = currentLayout };
            }
        }
        catch
        {
            article = new() { Layout = currentLayout };
        }
    }

    private async Task SaveArticle()
    {
        article.Layout = currentLayout;
        article.ModifiedAt = DateTime.UtcNow;
        await LocalStorage.SetItemAsync(Constants.Storage.ArticleKey, article);
    }

    private void LoadDemo()
    {
        article = new ArticleData
        {
            Title = "Premium Produkt XYZ-3000",
            Subtitle = "Hochwertige Qualit√§t | Art.-Nr. XYZ-3000-BK",
            MobileSummary = "Das Premium Produkt XYZ-3000 √ºberzeugt durch erstklassige Verarbeitung und innovative Features. Perfekt geeignet f√ºr anspruchsvolle Anwender, die Wert auf Qualit√§t legen.",
            Footer = "SKU: XYZ-3000-BK\nFarbe: Schwarz\nGarantie: 2 Jahre",
            Layout = currentLayout
        };

        foreach (var block in currentLayout.Blocks)
        {
            article.SetBlockContent(block.Id, block.Type.GetDemoContent());
        }
    }

    private void ResetArticle() => article = new() { Layout = currentLayout };

    private void SetContent(string blockId, ChangeEventArgs e) 
        => article.SetBlockContent(blockId, e.Value?.ToString() ?? string.Empty);

    private void ClearBlock(string blockId) => article.ClearBlockContent(blockId);

    private async Task UploadImage(InputFileChangeEventArgs e, string blockId)
    {
        try
        {
            var file = e.File;
            if (file.Size > Constants.FileLimits.MaxImageSizeBytes)
            {
                await ShowNotification("Bild zu gro√ü (max. 5 MB)", false);
                return;
            }
            
            await using var stream = file.OpenReadStream(Constants.FileLimits.MaxImageSizeBytes);
            using var ms = new MemoryStream();
            await stream.CopyToAsync(ms);
            var base64 = Convert.ToBase64String(ms.ToArray());
            article.SetBlockContent(blockId, $"data:{file.ContentType};base64,{base64}");
            StateHasChanged();
        }
        catch (Exception ex)
        {
            await ShowNotification($"Upload fehlgeschlagen: {ex.Message}", false);
        }
    }

    private async Task ExportArticle()
    {
        article.Layout = currentLayout;
        var json = JsonSerializer.Serialize(article, Helpers.JsonOptions);
        await JS.InvokeVoidAsync("downloadFile", article.GenerateFileName(), "application/json", json);
    }

    private async Task ImportArticle(InputFileChangeEventArgs e)
    {
        try
        {
            await using var stream = e.File.OpenReadStream(Constants.FileLimits.MaxImportSizeBytes);
            importedArticle = await JsonSerializer.DeserializeAsync<ArticleData>(stream);
            
            if (importedArticle is null) return;
            
            if (!currentLayout.IsCompatibleWith(importedArticle.Layout))
            {
                showImportConflict = true;
            }
            else
            {
                article = importedArticle;
                article.Layout = currentLayout;
                await ShowNotification("‚úì Artikel importiert!", true);
            }
        }
        catch (Exception ex)
        {
            await ShowNotification($"Import fehlgeschlagen: {ex.Message}", false);
        }
    }

    private async Task ImportWithNewLayout()
    {
        if (importedArticle?.Layout is null) return;
        
        if (!layouts.Exists(l => l.Id == importedArticle.Layout.Id))
        {
            importedArticle.Layout.IsDefault = false;
            layouts.Add(importedArticle.Layout);
            await SaveLayouts();
        }
        
        selectedLayoutId = importedArticle.Layout.Id;
        currentLayout = importedArticle.Layout;
        article = importedArticle;
        showImportConflict = false;
        await ShowNotification("‚úì Artikel mit Layout importiert!", true);
    }

    private async Task ImportKeepLayout()
    {
        if (importedArticle is null) return;
        
        article.Title = importedArticle.Title;
        article.Subtitle = importedArticle.Subtitle;
        article.MobileSummary = importedArticle.MobileSummary;
        article.Footer = importedArticle.Footer;
        
        foreach (var block in currentLayout.Blocks)
        {
            if (importedArticle.BlockContents.TryGetValue(block.Id, out var content))
            {
                article.SetBlockContent(block.Id, content);
            }
        }
        
        showImportConflict = false;
        await ShowNotification("‚úì Daten importiert", true);
    }

    private async Task CopyJsonSchema()
    {
        var schema = ArticleData.GenerateJsonSchema(currentLayout);
        await JS.InvokeVoidAsync("navigator.clipboard.writeText", schema);
        await ShowNotification("‚úì JSON-Schema kopiert!", true);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê NAVIGATION & HTML ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    private async Task GoToPhase(int phase)
    {
        if (phase >= 2)
        {
            article.Layout = currentLayout;
            generatedHtml = TemplateGenerator.GenerateHtml(article);
        }
        
        currentPhase = phase;
        await SaveArticle();
        
        if (phase == 0)
        {
            await Task.Delay(Constants.Timing.DomRenderDelayMs);
            await InitSortable();
        }
    }

    private async Task CopyHtml()
    {
        try
        {
            await JS.InvokeVoidAsync("navigator.clipboard.writeText", generatedHtml);
            await ShowNotification("‚úì HTML kopiert!", true);
        }
        catch
        {
            await ShowNotification("Kopieren fehlgeschlagen", false);
        }
    }

    private async Task DownloadHtml()
    {
        await JS.InvokeVoidAsync("downloadFile", article.GenerateFileName("html"), "text/html", generatedHtml);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê HELPERS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    private string GetPhaseClass(int phase) => currentPhase == phase ? "active" : currentPhase > phase ? "completed" : "";
    
    private static string GetPhaseName(int phase) => phase switch 
    { 
        0 => "Layout", 
        1 => "Eingabe", 
        2 => "Vorschau", 
        _ => "HTML" 
    };
    
    private int GetFooterLines() => string.IsNullOrWhiteSpace(article.Footer) 
        ? 0 
        : article.Footer.Split('\n', StringSplitOptions.RemoveEmptyEntries).Length;
    
    private static int GetTextareaRows(BlockType type) => type switch
    {
        BlockType.RichText => 6,
        BlockType.KeyValueGrid => 7,
        BlockType.DataTable => 8,
        BlockType.FeatureCards => 3,
        BlockType.CheckList => 5,
        _ => 4
    };

    private async Task ShowNotification(string msg, bool success)
    {
        notificationCts?.Cancel();
        notificationCts = new CancellationTokenSource();
        
        notification = msg;
        notificationSuccess = success;
        StateHasChanged();
        
        try
        {
            await Task.Delay(Constants.Timing.NotificationDurationMs, notificationCts.Token);
            notification = string.Empty;
            StateHasChanged();
        }
        catch (TaskCanceledException)
        {
            // Notification was replaced by another one
        }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê RENDER METHODS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    private RenderFragment RenderLayoutPhase() => __builder =>
    {
        <div class="phase-content layout-phase">
            <div class="toolbar">
                <select class="layout-select" @bind="selectedLayoutId" @bind:after="OnLayoutSelected">
                    @foreach (var l in layouts)
                    {
                        <option value="@l.Id">@l.Name @(l.IsDefault ? "(Standard)" : "")</option>
                    }
                </select>
                <button class="btn btn-secondary" @onclick="CreateNewLayout" title="Neues Layout erstellen">
                    <span class="icon">‚ûï</span> Neu
                </button>
                <button class="btn btn-secondary" @onclick="DuplicateLayout" title="Layout duplizieren">
                    <span class="icon">üìã</span> Duplizieren
                </button>
                <button class="btn btn-secondary" @onclick="ExportLayout" title="Layout exportieren">
                    <span class="icon">üì§</span> Export
                </button>
                <label class="btn btn-secondary" title="Layout importieren">
                    <span class="icon">üì•</span> Import
                    <InputFile OnChange="ImportLayout" accept=".json" style="display: none;" />
                </label>
                <button class="btn btn-danger" @onclick="DeleteLayout" 
                        disabled="@(currentLayout.IsDefault || layouts.Count <= 1)" 
                        title="Layout l√∂schen">
                    <span class="icon">üóëÔ∏è</span>
                </button>
            </div>

            <div class="layout-editor">
                <div class="layout-sidebar">
                    <div class="sidebar-section">
                        <label>Layout-Name</label>
                        <input type="text" @bind="currentLayout.Name" @bind:after="SaveLayouts" 
                               disabled="@currentLayout.IsDefault" placeholder="Layout-Name" />
                    </div>

                    <div class="sidebar-section">
                        <div class="section-header">
                            <h3>Bl√∂cke</h3>
                            <button class="btn btn-small btn-accent" @onclick="() => showAddBlockDialog = true">
                                <span class="icon">‚ûï</span>
                            </button>
                        </div>
                        <div class="block-list" id="block-list">
                            @foreach (var block in currentLayout.Blocks.OrderBy(b => b.Order))
                            {
                                <div class="block-item @(selectedBlockId == block.Id ? "selected" : "")"
                                     data-id="@block.Id"
                                     @onclick="() => SelectBlock(block)">
                                    <span class="drag-handle">‚ò∞</span>
                                    <span class="block-icon">@block.Icon</span>
                                    <span class="block-title">@block.Title</span>
                                    <span class="block-type">@block.Type.GetDisplayName()</span>
                                </div>
                            }
                        </div>
                    </div>

                    <div class="sidebar-section">
                        <h3>üé® Farbschema</h3>
                        <div class="color-row">
                            <label>Prim√§r</label>
                            <input type="color" @bind="currentLayout.Colors.PrimaryColor" @bind:after="SaveLayouts" />
                            <input type="text" class="color-text" @bind="currentLayout.Colors.PrimaryColor" @bind:after="SaveLayouts" />
                        </div>
                        <div class="color-row">
                            <label>Akzent</label>
                            <input type="color" @bind="currentLayout.Colors.AccentColor" @bind:after="SaveLayouts" />
                            <input type="text" class="color-text" @bind="currentLayout.Colors.AccentColor" @bind:after="SaveLayouts" />
                        </div>
                        <div class="color-row">
                            <label>Hintergrund</label>
                            <input type="color" @bind="currentLayout.Colors.BackgroundColor" @bind:after="SaveLayouts" />
                            <input type="text" class="color-text" @bind="currentLayout.Colors.BackgroundColor" @bind:after="SaveLayouts" />
                        </div>
                    </div>
                </div>

                <div class="block-editor">
                    @if (SelectedBlock is not null)
                    {
                        <h3>Block bearbeiten</h3>
                        
                        <div class="editor-group">
                            <label>Block-Typ</label>
                            <select @bind="SelectedBlock.Type" @bind:after="OnBlockTypeChanged">
                                @foreach (BlockType t in Enum.GetValues<BlockType>())
                                {
                                    <option value="@t">@t.GetDisplayName()</option>
                                }
                            </select>
                        </div>

                        <div class="editor-group">
                            <label>Icon</label>
                            <div class="icon-picker">
                                @foreach (var icon in Constants.AvailableIcons)
                                {
                                    <button type="button" class="icon-btn @(SelectedBlock.Icon == icon ? "selected" : "")"
                                            @onclick="() => SetBlockIcon(icon)">@icon</button>
                                }
                            </div>
                        </div>

                        <div class="editor-group">
                            <label>√úberschrift</label>
                            <input type="text" @bind="SelectedBlock.Title" @bind:after="SaveLayouts" />
                        </div>

                        @RenderBlockOptions(SelectedBlock)

                        <div class="editor-actions">
                            <button class="btn btn-danger" @onclick="DeleteBlock">
                                <span class="icon">üóëÔ∏è</span> Block l√∂schen
                            </button>
                        </div>
                    }
                    else
                    {
                        <div class="no-selection">
                            <p>W√§hle einen Block aus der Liste.</p>
                            <p>Ziehe Bl√∂cke per Drag & Drop, um die Reihenfolge zu √§ndern.</p>
                        </div>
                    }
                </div>
            </div>

            <div class="nav-buttons">
                <div></div>
                <button class="btn btn-primary btn-large" @onclick="() => GoToPhase(1)">
                    Weiter zur Eingabe <span class="icon">‚Üí</span>
                </button>
            </div>
        </div>
    };

    private RenderFragment RenderBlockOptions(BlockDefinition block) => __builder =>
    {
        @if (block.Type == BlockType.KeyValueGrid)
        {
            <div class="editor-group">
                <label>Spalten</label>
                <select @bind="block.Options.Columns" @bind:after="SaveLayouts">
                    <option value="1">1 Spalte</option>
                    <option value="2">2 Spalten</option>
                    <option value="3">3 Spalten</option>
                </select>
            </div>
            @RenderBulletPicker(block)
        }

        @if (block.Type == BlockType.DataTable)
        {
            <div class="editor-group">
                <label>Spalte 1</label>
                <input type="text" @bind="block.Options.Column1Header" @bind:after="SaveLayouts" />
            </div>
            <div class="editor-group">
                <label>Spalte 2</label>
                <input type="text" @bind="block.Options.Column2Header" @bind:after="SaveLayouts" />
            </div>
            <div class="editor-group checkbox-group">
                <label>
                    <input type="checkbox" @bind="block.Options.ShowColumnHeaders" @bind:after="SaveLayouts" />
                    Spalten√ºberschriften
                </label>
            </div>
            <div class="editor-group checkbox-group">
                <label>
                    <input type="checkbox" @bind="block.Options.AlternatingBackground" @bind:after="SaveLayouts" />
                    Zebra-Streifen
                </label>
            </div>
        }

        @if (block.Type == BlockType.CheckList)
        {
            @RenderBulletPicker(block)
        }

        @if (block.Type == BlockType.Image)
        {
            <div class="editor-group">
                <label>Ausrichtung</label>
                <select @bind="block.Options.Alignment" @bind:after="SaveLayouts">
                    <option value="left">Links</option>
                    <option value="center">Zentriert</option>
                    <option value="right">Rechts</option>
                </select>
            </div>
            <div class="editor-group">
                <label>Max. Breite (px)</label>
                <input type="number" @bind="block.Options.MaxWidth" @bind:after="SaveLayouts" min="100" max="800" />
            </div>
        }
    };

    private RenderFragment RenderBulletPicker(BlockDefinition block) => __builder =>
    {
        <div class="editor-group">
            <label>Aufz√§hlungszeichen</label>
            <div class="bullet-picker">
                @foreach (var b in Constants.AvailableBullets)
                {
                    <button type="button" class="bullet-btn @(block.Options.BulletChar == b ? "selected" : "")"
                            @onclick="() => SetBullet(b)">@b</button>
                }
            </div>
        </div>
    };

    private RenderFragment RenderInputPhase() => __builder =>
    {
        <div class="phase-content input-phase">
            <div class="toolbar">
                <button class="btn btn-secondary" @onclick="LoadDemo">
                    <span class="icon">üìã</span> Demo
                </button>
                <button class="btn btn-secondary" @onclick="ResetArticle">
                    <span class="icon">üóëÔ∏è</span> Zur√ºcksetzen
                </button>
                <button class="btn btn-secondary" @onclick="CopyJsonSchema">
                    <span class="icon">ü§ñ</span> JSON-Schema
                </button>
                <button class="btn btn-secondary" @onclick="ExportArticle">
                    <span class="icon">üì§</span> Export
                </button>
                <label class="btn btn-secondary">
                    <span class="icon">üì•</span> Import
                    <InputFile OnChange="ImportArticle" accept=".json" style="display: none;" />
                </label>
            </div>

            <div class="form-grid">
                <div class="form-section">
                    <h2>üìå Header</h2>
                    <div class="form-group">
                        <label>Titel</label>
                        <input type="text" @bind="article.Title" placeholder="Produktname" />
                    </div>
                    <div class="form-group">
                        <label>Untertitel</label>
                        <input type="text" @bind="article.Subtitle" placeholder="Kurzbeschreibung ‚îÇ Artikelnummer" />
                    </div>
                </div>

                <div class="form-section">
                    <h2>üì± Mobile Summary</h2>
                    <div class="form-group">
                        <label>Zusammenfassung (max. @Constants.Limits.MaxMobileSummaryLength Zeichen)</label>
                        <textarea @bind="article.MobileSummary" rows="3" 
                                  placeholder="Kurze Produktbeschreibung f√ºr Mobile..."></textarea>
                        <span class="char-count @(article.MobileSummary?.Length > Constants.Limits.MaxMobileSummaryLength ? "over-limit" : "")">
                            @(article.MobileSummary?.Length ?? 0) / @Constants.Limits.MaxMobileSummaryLength
                        </span>
                    </div>
                </div>

                @foreach (var block in currentLayout.Blocks.OrderBy(b => b.Order))
                {
                    <div class="form-section">
                        <div class="section-header">
                            <h2>@block.Icon @block.Title</h2>
                            <button class="btn-clear" @onclick="() => ClearBlock(block.Id)" title="L√∂schen">√ó</button>
                        </div>
                        <div class="form-group">
                            <label>@block.Type.GetInputLabel()</label>
                            @if (block.Type == BlockType.Image)
                            {
                                <div class="input-with-button">
                                    <input type="text" value="@article.GetBlockContent(block.Id)" 
                                           @onchange="e => SetContent(block.Id, e)" placeholder="https://..." />
                                    <label class="btn btn-accent">
                                        <span class="icon">üì∑</span>
                                        <InputFile OnChange="e => UploadImage(e, block.Id)" accept="image/*" style="display: none;" />
                                    </label>
                                </div>
                                @if (!string.IsNullOrEmpty(article.GetBlockContent(block.Id)))
                                {
                                    <div class="image-preview">
                                        <img src="@article.GetBlockContent(block.Id)" alt="Vorschau" />
                                    </div>
                                }
                            }
                            else
                            {
                                <textarea value="@article.GetBlockContent(block.Id)"
                                          @onchange="e => SetContent(block.Id, e)"
                                          rows="@GetTextareaRows(block.Type)"
                                          placeholder="@block.Type.GetInputPlaceholder()"></textarea>
                            }
                        </div>
                    </div>
                }

                <div class="form-section">
                    <div class="section-header">
                        <h2>üè∑Ô∏è Fu√üzeile</h2>
                        <button class="btn-clear" @onclick="() => article.Footer = string.Empty" title="L√∂schen">√ó</button>
                    </div>
                    <div class="form-group">
                        <label>Pro Zeile ein Eintrag, max. @Constants.Limits.MaxFooterLines Zeilen (Format: Label: Wert)</label>
                        <textarea @bind="article.Footer" rows="4" 
                                  placeholder="SKU: ABC123&#10;Farbe: Schwarz&#10;Garantie: 2 Jahre"></textarea>
                        <span class="char-count @(GetFooterLines() > Constants.Limits.MaxFooterLines ? "over-limit" : "")">
                            @GetFooterLines() / @Constants.Limits.MaxFooterLines Zeilen
                        </span>
                    </div>
                </div>
            </div>

            <div class="nav-buttons">
                <button class="btn btn-secondary btn-large" @onclick="() => GoToPhase(0)">
                    <span class="icon">‚Üê</span> Layout
                </button>
                <button class="btn btn-primary btn-large" @onclick="() => GoToPhase(2)">
                    Vorschau <span class="icon">‚Üí</span>
                </button>
            </div>
        </div>
    };

    private RenderFragment RenderPreviewPhase() => __builder =>
    {
        <div class="phase-content preview-phase">
            <div class="preview-container">
                <div class="preview-frame">
                    @((MarkupString)generatedHtml)
                </div>
            </div>

            <div class="nav-buttons">
                <button class="btn btn-secondary btn-large" @onclick="() => GoToPhase(1)">
                    <span class="icon">‚Üê</span> Eingabe
                </button>
                <button class="btn btn-primary btn-large" @onclick="() => GoToPhase(3)">
                    HTML <span class="icon">‚Üí</span>
                </button>
            </div>
        </div>
    };

    private RenderFragment RenderHtmlPhase() => __builder =>
    {
        <div class="phase-content html-phase">
            <div class="html-container">
                <div class="html-toolbar">
                    <button class="btn btn-primary" @onclick="CopyHtml">
                        <span class="icon">üìã</span> Kopieren
                    </button>
                    <button class="btn btn-accent" @onclick="DownloadHtml">
                        <span class="icon">üíæ</span> Herunterladen
                    </button>
                </div>
                <pre class="html-code"><code>@generatedHtml</code></pre>
            </div>

            <div class="nav-buttons">
                <button class="btn btn-secondary btn-large" @onclick="() => GoToPhase(2)">
                    <span class="icon">‚Üê</span> Vorschau
                </button>
                <button class="btn btn-secondary btn-large" @onclick="() => GoToPhase(1)">
                    <span class="icon">üîÑ</span> Neuer Artikel
                </button>
            </div>
        </div>
    };

    private RenderFragment RenderDialogs() => __builder =>
    {
        @if (showAddBlockDialog)
        {
            <div class="modal-overlay" @onclick="() => showAddBlockDialog = false">
                <div class="modal-dialog" @onclick:stopPropagation>
                    <h3>Block hinzuf√ºgen</h3>
                    <div class="block-type-list">
                        @foreach (BlockType t in Enum.GetValues<BlockType>())
                        {
                            <button class="block-type-btn" @onclick="() => AddBlock(t)">
                                <span class="icon">@t.GetDefaultIcon()</span>
                                <span class="name">@t.GetDisplayName()</span>
                            </button>
                        }
                    </div>
                    <button class="btn btn-secondary" @onclick="() => showAddBlockDialog = false">Abbrechen</button>
                </div>
            </div>
        }

        @if (showImportConflict)
        {
            <div class="modal-overlay" @onclick="() => showImportConflict = false">
                <div class="modal-dialog" @onclick:stopPropagation>
                    <h3>‚ö†Ô∏è Layout-Konflikt</h3>
                    <p>Das importierte Layout unterscheidet sich vom aktuellen.</p>
                    <p><strong>Aktuell:</strong> @currentLayout.Name (@currentLayout.Blocks.Count Bl√∂cke)</p>
                    <p><strong>Import:</strong> @importedArticle?.Layout?.Name (@importedArticle?.Layout?.Blocks.Count Bl√∂cke)</p>
                    
                    <div class="modal-actions">
                        <button class="btn btn-primary" @onclick="ImportWithNewLayout">Layout aus Datei √ºbernehmen</button>
                        <button class="btn btn-secondary" @onclick="ImportKeepLayout">Versuchen, Daten einzupassen</button>
                        <button class="btn btn-secondary" @onclick="() => showImportConflict = false">Abbrechen</button>
                    </div>
                </div>
            </div>
        }
    };

    private RenderFragment RenderNotification() => __builder =>
    {
        @if (!string.IsNullOrEmpty(notification))
        {
            <div class="notification @(notificationSuccess ? "success" : "error")">@notification</div>
        }
    };
}
